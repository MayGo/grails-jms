<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>3. The Configuration Mechanism</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h1><a name="3. The Configuration Mechanism">3. The Configuration Mechanism</a></h1>JMS is a complicated topic. There are different consumption and configuration patterns. While this plugin does set some reasonable defaults, it's very likely that you are going to need to customise these settings either globally or for specific senders or listeners.<p class="paragraph"/>To support this, the plugin makes <em class="italic">every</em> configuration option available to you should you need to set it. This is achieved through the use of Spring's abstract beans and Grails' configuration mechanism.<p class="paragraph"/><h3>How it works</h3><p class="paragraph"/>The configuration is controlled by the Grails application configuration under the key <code>jms</code>. This is merged against plugin provided defaults.<p class="paragraph"/>Here is what the defaults look like...<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.springframework.jms.support.converter.SimpleMessageConverter
<span class="java&#45;keyword">import</span> org.springframework.jms.listener.DefaultMessageListenerContainer<p class="paragraph"/>templates &#123;
    standard &#123;
        connectionFactoryBean = <span class="java&#45;quote">"jmsConnectionFactory"</span>
        messageConverter = <span class="java&#45;keyword">new</span> SimpleMessageConverter()
    &#125;
&#125;
containers &#123;
    standard &#123;
        concurrentConsumers = 1
        subscriptionDurable = <span class="java&#45;keyword">false</span>
        autoStartup = <span class="java&#45;keyword">false</span>
        connectionFactoryBean = <span class="java&#45;quote">"jmsConnectionFactory"</span>
        messageSelector = <span class="java&#45;keyword">null</span>
        cacheLevel = DefaultMessageListenerContainer.CACHE_SESSION
    &#125;
&#125;
adapters &#123;
    standard &#123;
        messageConverter = <span class="java&#45;keyword">new</span> SimpleMessageConverter()
        persistenceInterceptorBean = 'persistenceInterceptor'
    &#125;
&#125;</pre></div><p class="paragraph"/>It's a BeanBuilder like syntax, but it is actually ConfigSlurper syntax. It creates a map of "bean definitions" that get processed into real bean definitions.<p class="paragraph"/>The default config creates our standard (i.e. default) jms templates for sending, and listener containers and adapters for receiving.<p class="paragraph"/>When sending messages with the <code>jmsService</code> you can specify which template to use to send the message. If none is specified, "standard" is used.<p class="paragraph"/>Likewise, listeners can specify which container and/or adapter bean definition to base themselves on. If none are specified, "standard" is used in both cases.<h2><a name="3.1 Changing Defaults">3.1 Changing Defaults</a></h2>You can override the configuration defaults very easily.<p class="paragraph"/>Let's suppose you do not want any message conversion on listeners. If a listener container has no <code>messageConverter</code> listeners will receive raw messages. So we want to override the standard listener container definition to set the <code>messageConverter</code> property to <code>null</code>.<p class="paragraph"/>In your application's <code>Config.groovy</code><p class="paragraph"/><div class="code"><pre>jms &#123;
    containers &#123;
        standard &#123;
            messageConverter = <span class="java&#45;keyword">null</span>
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>This definition will get merged against the plugin provided defaults to produce a standard listener container definition with <code>messageConverter</code> set to <code>null</code>.<h2><a name="3.2 Syntax Notes">3.2 Syntax Notes</a></h2>There are some noteworthy things about this config syntax.<p class="paragraph"/><h4>Bean names</h4><p class="paragraph"/>The beans created automatically get suffixes applied to them. Template bean names get suffixed with 'JmsTemplate', container beans get suffixed with 'JmsListenerContainer' and adapter beans get suffixed with 'JmsListenerAdapter'.<p class="paragraph"/><h4>Setting Beans</h4><p class="paragraph"/>To set a property to another Spring bean, simply append <code>Bean</code> to the property name and set the property to the name of the bean.<p class="paragraph"/>Here is how the standard template is defined to use the bean named <code>jmsConnectionFactory</code> as it's connection factory...<p class="paragraph"/><div class="code"><pre>templates &#123;
    standard &#123;
        connectionFactoryBean = <span class="java&#45;quote">"jmsConnectionFactory"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/><h4>Setting Class</h4><p class="paragraph"/>To set the class of a bean, you must use the following syntax<p class="paragraph"/><div class="code"><pre>templates &#123;
    standard &#123;
        meta &#123;
            clazz = my.org.CustomJmsTemplate
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/><h4>Extending Definitions</h4><p class="paragraph"/>Bean definition can inherit from parents and selectively override settings.<p class="paragraph"/><div class="code"><pre>templates &#123;
    other &#123;
        meta &#123;
            parentBean = 'standardJmsTemplate'
        &#125;
        connectionFactoryBean = <span class="java&#45;quote">"someOtherJmsConnectionFactory"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>This creates an "other" template, that inherits all of the standard settings but uses a custom connectionFactory.
	</body>
</html>