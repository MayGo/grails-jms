<html>
	<head>
		  <title>grails-jms 0.5-SNAPSHOT - Reference Documentation</title>
		  <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Style" charset="utf-8">	
	</head>
    <body class="body">
		<div id="header">
				<div class="images"><br><br>
				   <a href="http://grails.org"  target="_blank"><img alt="The Grails Framework" src="../img/grails.png" border="0"></a>
				   <span style="right:30px; top:20px; position:absolute;">
					<a href="../index.html" target="_top">Frames</a> | <a href="index.html" target="_top">No Frames</a><br><br>
                     <a alt="SpringSource - A Division of VMware" href="http://springsource.com" target="_blank"><img src="../img/springsource-logo.png" border="0"></a>					
					</span>					
				</div>
				<div class="message">grails-jms</div>
				<h1>grails-jms - Reference Documentation</h1>
				<p><strong>Authors:</strong> Luke Daley</p>
				<p><strong>Version:</strong> 0.5-SNAPSHOT</p>				
				<em></em>
		</div>                       
		
		<div id="toc">  
			<h2>Table of Contents</h2>
			<div class="tocItem" style="margin-left:0px"><a href="#1. Introduction">1. Introduction</a></div><div class="tocItem" style="margin-left:0px"><a href="#2. Plugging in a JMS Provider">2. Plugging in a JMS Provider</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.1 ActiveMQ Example">2.1 ActiveMQ Example</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.2 Connection Pooling">2.2 Connection Pooling</a></div><div class="tocItem" style="margin-left:0px"><a href="#3. Sending Messages">3. Sending Messages</a></div><div class="tocItem" style="margin-left:0px"><a href="#4. Receiving Messages">4. Receiving Messages</a></div>
		</div>     
		<div id="content">
			<h1><a name="1. Introduction">1. Introduction</a></h1>This plugin makes it easy to both send and receive JMS messages inside a Grails application. It is built on top of <a href="http://static.springsource.org/spring/docs/3.0.x/reference/html/jms.html." target="blank">Spring's JMS support</a><p class="paragraph"/>There are some core Spring JMS concepts that you should at least be aware of in order to use grails-jms.<p class="paragraph"/><h2>JmsTemplate</h2><p class="paragraph"/>Spring provides <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jms/core/JmsTemplate.html" target="blank">JmsTemplate</a> which is what this plugin uses to send messages.<p class="paragraph"/><h2>MessageConverter</h2><p class="paragraph"/>The <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jms/support/converter/MessageConverter.html" target="blank">MessageConverter</a> abstraction conveniently allows pluggable message conversion. By default, this plugin uses Spring's <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jms/support/converter/SimpleMessageConverter.html" target="blank">SimpleMessageConverter</a> which handles 'standard' message payloads and JMS Message types.<p class="paragraph"/><h2>MessageListenerContainer</h2><p class="paragraph"/>A listener container polls a JMS destination for messages. Each listener (i.e. each service method that receives JMS messages) has it's own listener container.<p class="paragraph"/>This plugin uses the <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jms/listener/DefaultMessageListenerContainer.html" target="blank">DefaultMessageListenerContainer</a> implementation.<p class="paragraph"/><h2>MessageListenerAdapter</h2><p class="paragraph"/>A listener adapter connects a listener container to the actual destination of the message. It handles message conversion amongst other things.<p class="paragraph"/>By default, this plugin uses a MessageListenerAdapter subclass that is Grails aware and sets up the necessary Grails environment for listener methods (e.g. Hibernate session).<h1><a name="2. Plugging in a JMS Provider">2. Plugging in a JMS Provider</a></h1>The plugin does not include a JMS provider so you must install and configure your own.<p class="paragraph"/>All you need to provide is one or more <a href="http://java.sun.com/javaee/5/docs/api/javax/jms/ConnectionFactory.html" target="blank">javax.jms.ConnectionFactory</a> beans and the plugin takes care of the rest.<p class="paragraph"/>By default, the plugin looks for a connection factory bean named <code>jmsConnectionFactory</code> but this is configurable.<h2><a name="2.1 ActiveMQ Example">2.1 ActiveMQ Example</a></h2>First we need the ActiveMQ core jar.<p class="paragraph"/>Our <code>BuildConfig.groovy</code> looks something like...<p class="paragraph"/><div class="code"><pre>grails.project.dependency.resolution = &#123;
    inherits <span class="java&#45;quote">"global"</span>
    log <span class="java&#45;quote">"warn"</span>
    repositories &#123;
        grailsHome()
        mavenCentral()
    &#125;  
    dependencies &#123;
        compile 'org.apache.activemq:activemq&#45;core:5.3.0'
    &#125;
&#125;</pre></div><p class="paragraph"/>Then in <code>resources.groovy</code>..
An example <code>resources.groovy</code> configuration for ActiveMQ would look something like…<p class="paragraph"/><div class="code"><pre>jmsConnectionFactory(org.apache.activemq.ActiveMQConnectionFactory) &#123;
	brokerURL = 'vm://localhost'
&#125;</pre></div><h2><a name="2.2 Connection Pooling">2.2 Connection Pooling</a></h2>This plugin uses Spring's <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jms/core/JmsTemplate.html" target="blank">JmsTemplate</a> under the covers. It's important that you understand the connection lifecycle behaviour of this class and use appropriate connection pooling.<p class="paragraph"/>Read <a href="http://activemq.apache.org/jmstemplate-gotchas.html." target="blank">ActiveMQ's article about this</a><p class="paragraph"/>One simple solution is to use Spring's <a href="http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jms/connection/SingleConnectionFactory.html" target="blank">SingleConnectionFactory</a> to reuse one connection across listening containers.<p class="paragraph"/>Here is an example of using it with ActiveMQ...<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory
<span class="java&#45;keyword">import</span> org.springframework.jms.connection.SingleConnectionFactory<p class="paragraph"/>beans = &#123;
    jmsConnectionFactory(SingleConnectionFactory) &#123;
        targetConnectionFactory = &#123; ActiveMQConnectionFactory cf &#45;&#62;
            brokerURL = 'vm://localhost'
        &#125;
    &#125;
&#125;</pre></div><h1><a name="3. Sending Messages">3. Sending Messages</a></h1><h2>Sending Messages</h2><p class="paragraph"/>The plugin also provides mechanisms to make sending messages easier. Underneath the hood, messages are sent via an instance of Spring's <a href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/jms/core/JmsTemplate.html" target="blank">JmsTemplate</a>. The plugin creates one instance of JmsTemplate named <code> defaultJmsTemplate </code> which uses the connection factory named <code> jmsConnectionFactory </code> .<p class="paragraph"/><h3>The jmsService</h3><p class="paragraph"/>This plugin adds a service called <code> jmsService </code> to your application that can be used to send JMS messages.<p class="paragraph"/><h4>The send(destination, message, jmsTemplateBeanName, postProcessor) method.</h4><p class="paragraph"/><strong class="bold">destination</strong><p class="paragraph"/>An instance of <code> javax.jms.Destination </code> , <code> javax.jms.Topic </code> , a <code> String </code> or a <code> Map </code> .<p class="paragraph"/>A <code> String </code> destination argument will be interpreted as the name of a destination <em class="italic">queue</em> .<p class="paragraph"/>A <code> Map </code> destination argument can be used in the following ways:<p class="paragraph"/><div class="code"><pre>jmsService.send(queue: <span class="java&#45;quote">"aQueue"</span>, msg, <span class="java&#45;quote">"defaultJmsTemplate"</span>, <span class="java&#45;keyword">null</span>) // send to a literal queue<p class="paragraph"/>jmsService.send(topic: <span class="java&#45;quote">"aTopic"</span>, msg, <span class="java&#45;quote">"defaultJmsTemplate"</span>, <span class="java&#45;keyword">null</span>) // send to a literal topic<p class="paragraph"/>jmsService.send(service: <span class="java&#45;quote">"person"</span>, msg, <span class="java&#45;quote">"defaultJmsTemplate"</span>, <span class="java&#45;keyword">null</span>) // send to the queue '«appname».person'<p class="paragraph"/>jmsService.send(service: <span class="java&#45;quote">"person"</span>, method: <span class="java&#45;quote">"doIt"</span>, msg, <span class="java&#45;quote">"defaultJmsTemplate"</span>, <span class="java&#45;keyword">null</span>) // send to the queue '«appname».person.doIt'<p class="paragraph"/>jmsService.send(app: <span class="java&#45;quote">"remote"</span>, service: <span class="java&#45;quote">"person"</span>, method: <span class="java&#45;quote">"doIt"</span>, msg, <span class="java&#45;quote">"defaultJmsTemplate"</span>, <span class="java&#45;keyword">null</span>) // send to the queue 'remote.person.doIt'</pre></div><p class="paragraph"/>The app/service/method convention makes a lot more sense if you read the section below on service method listener queue subscribers.<p class="paragraph"/><strong class="bold">message</strong><p class="paragraph"/>This is the message payload. This can either be a <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html" target="blank">javax.jms.Message</a> or a Groovy/Java object to be <em class="italic">converted</em> into a message by the underlying <a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/jms/support/converter/MessageConverter.html" target="blank">MessageConverter</a> of the <a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/jms/core/JmsTemplate.html" target="blank">JmsTemplate</a> used to send the message.<p class="paragraph"/><strong class="bold">jmsTemplateBeanName</strong><p class="paragraph"/>The name of the bean in the application context that is an instance of <a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/jms/core/JmsTemplate.html" target="blank">JmsTemplate</a> and that should be used to send the message. If this value is <code> null </code> , the default template that is created by this plugin will be used (called "defaultJmsTemplate").<p class="paragraph"/><strong class="bold">postProcessor</strong><p class="paragraph"/>An optional closure that can be used to "post process" the message after it has been converted into a message but before it has been sent. This closure acts as the implementation of the <a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/jms/core/MessagePostProcessor.html#postProcessMessage(javax.jms.Message)" target="blank">postProcessMessage()</a> method of the <a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/jms/core/MessagePostProcessor.html" target="blank">MessagePostProcessor</a> class.<p class="paragraph"/><h4>send() method variants</h4><p class="paragraph"/>There are variations of the send() method for convenience...<p class="paragraph"/><div class="code"><pre>jmsService.send(destination, message) // use the defaultJmsTemplate and no post processor
jmsService.send(destination, message, postProcessor) // use the defaultJmsTemplate</pre></div><p class="paragraph"/><h3>Sending directly from services and controllers</h3><p class="paragraph"/>The JMS plugin dynamically adds convenient methods to all your services and controllers to make sending messages easier.<p class="paragraph"/><strong class="bold">Note:</strong> each of the methods shares the same semantics as <code> jmsService.send() </code> with respect to optional arguments.<p class="paragraph"/><h4>sendJMSMessage()</h4><p class="paragraph"/>This method shares exactly the same signature and semantics as the send() method of the JmsService.<p class="paragraph"/><h4>sendQueueJMSMessage()</h4><p class="paragraph"/>This method shares exactly the same signature and semantics as the send() method of the JmsService <strong class="bold">EXCEPT</strong> that the destination argument must be a string which will be interpreted as a QUEUE name.<p class="paragraph"/><h4>sendTopicJMSMessage()</h4><p class="paragraph"/>This method shares exactly the same signature and semantics as the send() method of the JmsService <strong class="bold">EXCEPT</strong> that the destination argument must be a string which will be interpreted as a TOPIC name.<p class="paragraph"/><h4>sendPubSubJMSMessage()</h4><p class="paragraph"/>This method shares exactly the same signature and semantics as the send() method of the JmsService <strong class="bold">EXCEPT</strong> that the destination argument must be a string which will be interpreted as a TOPIC name.<h1><a name="4. Receiving Messages">4. Receiving Messages</a></h1><h2>Consuming Messages</h2><p class="paragraph"/><h3>Service Listeners</h3><p class="paragraph"/>Service listeners are a convenient way to define one handler for JMS messages. The simplest service listener looks like…<p class="paragraph"/><div class="code"><pre>class PersonService &#123;
	<span class="java&#45;keyword">static</span> exposes = &#91;<span class="java&#45;quote">"jms"</span>&#93;
	def onMessage(msg) &#123;
		// handle message
	&#125;
&#125;</pre></div><p class="paragraph"/>This will register the <code>onMessage</code> method as a listener for the JMS <em class="italic">topic</em> named <code>«application name».person</code> , where «application name» is the <code>app.name</code> key from the <code>application.properties</code> file.<p class="paragraph"/><blockquote class="note">
The return value of onMessage may be sent to a reply queue depending on your configuration. Be careful - due to Groovy's implicit return mechanism, ensure that you return null explicitly if you want nothing to be sent to the reply queue after your onMessage call. For example if you accidentally return a value that cannot be sent to a reply queue, you may have odd side effects like messages never being removed from the queue (due to implicit rollbacks!).
</blockquote><p class="paragraph"/>By default, listener methods receive the payload of the message as extracted by a <a href="http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/jms/support/converter/SimpleMessageConverter.html" target="blank">SimpleMessageConverter</a> instance. You can use the “messageConverter” configuration parameter of your listener (details below) to either specify a custom converter or to not use a converter at all and receive the <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html" target="blank">Message</a> instance instead of the payload.<p class="paragraph"/><h4>Configuration</h4><p class="paragraph"/>The following configuration parameters can be set as static variables on the service class…<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th>Property Name</th><th>Type</th><th>Default</th><th>Description</th></tr><tr class="table-odd"><td><strong class="bold">listenerCount</strong></td><td>Number</td><td>1</td><td>The number of concurrent listeners to spawn to listen for messages</td></tr><tr class="table-even"><td><strong class="bold">destination</strong></td><td>String</td><td>«app name».«service name»</td><td>The named destination of the listener</td></tr><tr class="table-odd"><td><strong class="bold">listenerMethod</strong></td><td>String</td><td>onMessage</td><td>The listener method that will handle the messages</td></tr><tr class="table-even"><td><strong class="bold">pubSub</strong></td><td>boolean</td><td>false</td><td>is the destination a topic ( <code>true</code> ) or a queue ( <code>false</code> )</td></tr><tr class="table-odd"><td><strong class="bold">messageSelector</strong></td><td>String</td><td>null</td><td>See the “Message Selector” section of http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html</td></tr><tr class="table-even"><td><strong class="bold">durable</strong></td><td>boolean</td><td>false</td><td>Creates a durable subscription to the topic (redundant if <code>pubSub = false</code> )</td></tr><tr class="table-odd"><td><strong class="bold">clientId</strong></td><td>String</td><td>«app name»</td><td>Provides a client identifier for durable subscriptions</td></tr><tr class="table-even"><td><strong class="bold">connectionFactory</strong></td><td>String</td><td>"jmsConnectionFactory"</td><td>The name of the connection factory bean to use to create a connection to the broker</td></tr><tr class="table-odd"><td><strong class="bold">messageConverter</strong></td><td>String</td><td>""</td><td>a <code>null</code> for no message converter, "" to use a <a href="http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/jms/support/converter/SimpleMessageConverter.html," target="blank">SimpleMessageConverter</a> otherwise the name of a bean implementing <a href="http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/jms/support/converter/MessageConverter.html" target="blank">MessageConverter</a> (See <a href="http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/jms/listener/adapter/MessageListenerAdapter.html" target="blank">discussion on type conversion</a> )</td></tr></table><p class="paragraph"/><h3>Service Method Listeners</h3><p class="paragraph"/>Another avenue is to expose specific methods as message listeners via annotations. This looks like…<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.jms.&#42;<p class="paragraph"/>class PersonService &#123;
	<span class="java&#45;keyword">static</span> exposes = &#91;<span class="java&#45;quote">"jms"</span>&#93;<p class="paragraph"/>	@Queue
	def addPerson(msg) &#123;<p class="paragraph"/>	&#125;<p class="paragraph"/>	@Subscriber
	def somethingHappened(msg) &#123;<p class="paragraph"/>	&#125;
&#125;</pre></div><p class="paragraph"/>The above configuration binds the <code>personService.addPerson()</code> method to a queue named <code>«app name».person.addPerson</code> and binds the method <code>personService.somethingHappened()</code> as a listener to the topic named <code>somethingHappened</code> .<p class="paragraph"/>Note that you still need to expose the class via ' <code> static exposes = &#91;"jms"] </code> .<p class="paragraph"/><h4><code>Queue Configuration</h4><p class="paragraph"/>The following configuration parameters can be set as annotation parameters…<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th>Property Name</th><th>Type</th><th>Default</th><th>Description</th></tr><tr class="table-odd"><td><strong class="bold">name</strong></td><td>String</td><td>«app name».«service name».«method name»</td><td>The destination name for the queue</td></tr><tr class="table-even"><td><strong class="bold">selector</strong></td><td>String</td><td>null</td><td>The message selector to apply (See the “Message Selector” section of http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html)</td></tr><tr class="table-odd"><td><strong class="bold">connectionFactory</strong></td><td>String</td><td>"jmsConnectionFactory"</td><td>The name of the connection factory bean to use to create a connection to the broker</td></tr><tr class="table-even"><td><strong class="bold">messageConverter</strong></td><td>String</td><td>""</td><td>a </code>null@ for no message converter, "" to use a <a href="http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/jms/support/converter/SimpleMessageConverter.html," target="blank">SimpleMessageConverter</a> otherwise the name of a bean implementing <a href="http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/jms/support/converter/MessageConverter.html" target="blank">MessageConverter</a> (See <a href="http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/jms/listener/adapter/MessageListenerAdapter.html" target="blank">discussion on type conversion</a> )</td></tr></table><p class="paragraph"/>Example…<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.jms.&#42;<p class="paragraph"/>class PersonService &#123;
	<span class="java&#45;keyword">static</span> exposes = &#91;<span class="java&#45;quote">"jms"</span>&#93;<p class="paragraph"/>	@Queue(
		name = <span class="java&#45;quote">"myQueue"</span>,
		selector = <span class="java&#45;quote">"name IS NOT NULL"</span>
	)
	def addPerson(msg) &#123;<p class="paragraph"/>	&#125;
&#125;</pre></div><p class="paragraph"/><h4><code>Subscriber Configuration</h4><p class="paragraph"/>The following configuration parameters can be set as annotation parameters…<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th>Property Name</th><th>Type</th><th>Default</th><th>Description</th></tr><tr class="table-odd"><td><strong class="bold">topic</strong></td><td>String</td><td>«method name»</td><td>The name of the topic to subscribe to</td></tr><tr class="table-even"><td><strong class="bold">selector</strong></td><td>String</td><td>null</td><td>The message selector to apply (See the “Message Selector” section of <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html" target="blank"></a>)</td></tr><tr class="table-odd"><td><strong class="bold">durable</strong></td><td>Boolean</td><td>false</td><td>Whether or not to create a durable subscription</td></tr><tr class="table-even"><td><strong class="bold">connectionFactory</strong></td><td>String</td><td>jmsConnectionFactory</td><td>The name of the connection factory bean to use to create a connection to the broker</td></tr><tr class="table-odd"><td><strong class="bold">messageConverter</strong></td><td>String</td><td>""</td><td>a </code>null@ for no message converter, "" to use a <a href="http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/jms/support/converter/SimpleMessageConverter.html," target="blank">SimpleMessageConverter</a> otherwise the name of a bean implementing <a href="http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/jms/support/converter/MessageConverter.html" target="blank">MessageConverter</a> (See <a href="http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/jms/listener/adapter/MessageListenerAdapter.html" target="blank">discussion on type conversion</a> )</td></tr></table><p class="paragraph"/>Example…<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.jms.&#42;<p class="paragraph"/>class PersonService &#123;
	<span class="java&#45;keyword">static</span> exposes = &#91;<span class="java&#45;quote">"jms"</span>&#93;<p class="paragraph"/>	@Subscriber(topic = <span class="java&#45;quote">"aTopic"</span>)
	def somethingHappened(msg) &#123;<p class="paragraph"/>	&#125;
&#125;</pre></div>         			
		</div>
		<div id="footer">
			  
		</div>	
	</body>
</html>